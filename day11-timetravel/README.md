# 오늘의 서기: 임은상
# day11-timetravel

## 오늘의 핵심
- timetravel : 실행 이력을 저장해두고, 과거로 돌아가 분석·재실험 가능
            - Checkpoint: 특정 시점 상태의 스냅샷
            - thread_id: 스레드 ID
            - Fork: 기존 결과를 덮지 않고 새로운 분기 생성 

## 회고 모음
- {{임정수}}:timetravel 기능을 이용해서 본래 사용할 재료들을 이전 값과 비교해서 다른 랜덤 값으로 바꾸는 구조를 설계 가능하다. 
- {{양승준}}:시간여행자가 되었다 
- {{백경만}}:과거 체크포인트로 돌아가 상태를 변경하고, 원본 이력은 보존한 채 새로운 시나리오로 분기 실행하는 기능 / vlm 상황 분류 후 llm api로 정밀 분석 시 상황 분류가 바뀌었을 때 적용 가능할 것으로 보임
- {{윤지연}}:AI 실행 이력을 단순 저장하는 것을 넘어, 특정 시점으로 되돌아가 상태를 수정하고 분기 실행하는 State 기반 Time Travel 디버깅 패턴을 습득함.

## 자주 나온 질문
- Q : day8에 배운 persistence는 단순히 조회에만 사용되는거고 오늘 배운것은 분기를 새로 생성하는것인가
  A : 모든건 persistence가 가능하기 때문에 된다! 마치 무도유니버스처럼
- Q : 이 예제를 사람 개입 승인/거절 흐름으로 바꾸면 Time Travel이 어디서 유용하나요?
  A : HITL하기 전으로 돌아가면 다른 선택을 가정한 분기를 만들 수 있지 않을까
- 이번 단계에서는 LangGraph의 Time Travel 및 상태 복원(Fork) 메커니즘을 이해하는 데 초점을 두어 VLM → LLM 단순 구조로 프로토타입을 구현하였다. 다음에는 VLM → 이상 검증 → 분류 검증 → 액션 → 보고서의 다단계 파이프라인으로 노드를 세분화해 구조를 확장해봐야겠다.