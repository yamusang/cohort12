# 오늘의 서기: 김민서
# day3-promptchainig

## 오늘의 핵심
- Prompt Chaining: LLM의 출력을 다음 단계의 입력으로 전달하여, 복잡한 작업을 단계별로 처리하는 기법을 익힘.
- LangGraph State: `TypedDict`로 상태를 정의하고 `StateGraph`를 통해 각 노드(함수) 간에 데이터를 효율적으로 공유하고 관리함.
- Conditional Edges: `check_punchline`과 같은 게이트 함수를 사용하여 조건에 따라 워크플로우를 분기(Pass/Fail)하는 제어 흐름을 구현함. 

## 회고 모음
- {{임정수}}: 제미나이는 저보다 농담을 잘합니다.
- {{양승준}}: 랭그래프를 이용한 프롬프트 체인만드는법을 배웠다
- {{윤지연}}: 유머도 재밌으려면 세밀한 설계를 요구한다.
- {{임은상}}: 프롬프트 체이닝에 대해 알 수 있었다.
- {{이선영}}: 프롬프트 체이닝은 여러 개의 프롬프트로 나누고 단계적으로 연결해서 최종 결과물을 도출하는 기법이다.
- {{박성빈}}: 프롬프트 체이닝을 통해 쉽게 DB 에서 원하는 것을 조회할 수 있게 되었다 개꿀딱
- {{곽수영}}: LLM 출력 결과에 따른 동적 라우팅 이해 -> LLM 출력 결과에 따른 조건부 체이닝 이해
- {{나이삭}}: LLM의 출력을 다음 단계의 입력으로 전달하는 'Prompt Chaining' 과정을 LangGraph의 기능과 흐름 구조화하는 핵심 원리 이해
- {{배정윤}}: 랭그래프라는 도구를 사용해서, 꼬꼬무 플로우(프롬프트 체이닝) 기법을 구현하는 것과 그래프 빌딩하는 것 그리고 LangSmith 사용법 익숙해 지기
- {{이영근}}: 복잡한 작업을 여러 개의 작은 하위 작업으로 나누어 순차적으로 연결된 프롬프트(명령어)를 통해 대규모 언어 모델(LLM)이 단계별로 해결하도록 하는 기법
- {{김동국}}: 오늘 이해한 핵심 한 가지
주제를 받아 농담을 만들고 조건에 따라 끝낼지 다음 단계로 진행 할 지를 알게 되었다.
- {{김민서}}: Tavily 검색으로 최신 정보를 파악하고, Gemini와 LangGraph를 통해 농담 생성부터 개선(반전 추가)까지 자동으로 수행하는 '검색 기반 유머 생성 파이프라인. pass 뜨면 재미없게 농담을 해서 개선을 하게 끔 fail 로 하드코딩했음.
(그럼에도 불구하고 농담을 잘 하는지는 잘 모르겠음)


## 자주 나온 질문
- 노드를 더 늘리거나 해보고 싶었지만 어떻게 해야하는지.
- 기능을 건드려보고 싶은데 어떻게 해야하는지.
- 하지만 예제를 응용해서 다른 작업도 해보고 싶은데 어디를 수정해야 할지, 어떤 함수를 써야 할지.
- invoke 로 바로 명령어를 입력하는 것과 구조화된 프로프팅을 했을때 좋은점
- LLM 구조화된 출력을 위한 증강과 TypedDict 차이점
- TypedDict 에서 처리하는게 장기적이나 비용적으로 훨씬 효율적이고 프롬프트에서 처리하는건 장점이 빠르다 인데 그럼에도 프롬프트에서 사용하는게 많이 보이는데 왜그런건지?
- 맵핑 테이블과 어떻게 연결되어 흐름을 제어하는지 그 연결 고리가 아직은 복잡하게 느껴짐.
- 랭체인과 랭그래프의 차이는 뭔가요?
- Prompt Chaining 어떻게 활용해야 하는 것인지