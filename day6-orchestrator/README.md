# 오늘의 서기: 박성빈
# day6-orchestrator

## 오늘의 핵심
- orchestrator (지휘자) : 작업을 쪼개고, 필요한 만큼 워커를 동적으로 생성/배분 (계획)
- Worker (일꾼) : 할당받은 세부 작업을 병렬로 동시 수행 (실행)
- Synthesizer (편집장) : 흩어진 작업 결과를 하나로 모아 통합 (정리)

## 회고 모음
- {{이영근}}: 쿠버네티스로 컨테이너화된 서비스(워커)들을 자동으로 관리하는거처럼 llm들을 자동으로 관리한다는 개념같다. 
- {{홍자영}}: 큰 task를 작은 걸로 나눠서 각각의 worker에게 할당하되 노드가 몇 개 생길지 예측이 안 되면 orchestration (된다면 직접 parallelization 해도 됨)
Send 에서 워커 동적 생성, Synthesizer 가 결과를 합침! (Sections가 되어 structured output/구조화된 출력으로 나온다) 
- {{임정수}}: 검수자 서비스를 추가해보면서 마음에 들지 않을 시 Rollback 루프를 3번 정도 실행하는 로직을 추가해봤습니다. 
- {{박성빈}}: AI 군단 지휘하기
- {{양승준}}: 오케스트레이터와 워커노드를 배웠다
- {{임은상}}: 오케스트레이터가 계획을 만들고 워커를 동적으로 만들어서 일하게 하고 신디사이저로 결과를 합친다.
- {{김동국}}: 병렬화와 다르게 AI가 동적으로 만들어서 일하게 하고 결과를 합쳤다.
- {{나이삭}}: 프롬프트라고 작성했는데 영어로 출력됨. Human Message에서 한국어로 출력 하라고 수정
헤비한 작업일 때 분업 별로 일을 처리한다는 것이 효율적임.

## 자주 나온 질문
- 워커를 ‘동적으로’ 만들어서 일 하게 하고에서 동적이라는게 와닿지가 않는다. 
=> 동적으로 만들지 않으면, 미리 다 계획하고, 노드를 다 만들어서 등록해둬야합니다
- 그래프 상태?
=> 노드와 노드 사이에서는 무슨 일이 일어나는지 원칙적으로 모릅니다. 그래서 state(상태값)을 갖고 정보를 공유해야만 하죠
- SystemMessage는 llm의 지침을 말하는건가?
=> “어떻게 행동해야 하는지”를 정하는 최상위 규칙이라고 보시면 되고, 사용자의 입력보다 더 쎄게? 먹힙니다.
- edges?
=> 그래프는 항상 노드와 엣지로 이뤄져있습니다. 노드는 일을 하는 함수, 엣지는 이 노드 다음에 어떤 노드로 갈지 정하는 연결 규칙입니다
- 6개 주제 입력 시 8개 워커가 생성되는 동적 할당을 직접 확인. 비동기라서 끝나는대로 로그가 뜨는게 흐뭇b
=> send+랭그래프 실행 엔진 == 병렬 실행입니다. 비동기랑 헷갈릴수도 있는데요
병렬은 여러 작업을 동시에 시작해 각각 독립적으로 실행 > 끝나는 시점 달랐던 이유
비동기는 한 작업의 대기 시간 동안 다른 작업을 처리하는 방식입니다.
- paralleization과 조금 헷갈리는거 같습니다
=> 딱 하나만 기억하심 돼요. 내가 작업을 어떻게 할지가 이미 정해져있다 == paralleization
내가 작업을 처리하기 위해 몇개의 함수가 필요한지 아직은 모르겠다 == orchestrator-worker
- 오케스트레이터끼리는 병렬 작업이 안되는 것 같습니다.
=> 이것도 병렬로 작업하고 싶으시다면, 또 더 상위에서 오케스트레이터한테 일을 줘야합니다
